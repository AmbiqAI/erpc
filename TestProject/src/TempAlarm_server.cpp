/*
 * Copyright (c) 2016, Freescale Semiconductor, Inc.
 * Copyright 2016-2017 NXP
 * All rights reserved.
 *
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/*
 * Generated by erpcgen 1.9.1 on Thu Aug 18 10:53:47 2022.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "TempAlarm_server.h"
#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
#include <new>
#include "erpc_port.h"
#endif
#include "erpc_manually_constructed.hpp"

#if 10901 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

#if ERPC_NESTED_CALLS_DETECTION
extern bool nestingDetection;
#endif

ERPC_MANUALLY_CONSTRUCTED_STATIC(Temp_service, s_Temp_service);

ERPC_MANUALLY_CONSTRUCTED_STATIC(TempAsync_service, s_TempAsync_service);


//! @brief Function to read struct binary_t
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data);

//! @brief Function to read struct SensorReadResult
static void read_SensorReadResult_struct(erpc::Codec * codec, SensorReadResult * data);


// Read struct binary_t function implementation
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data)
{
    if(NULL == data)
    {
        return;
    }

    uint8_t * data_local;
    codec->readBinary(&data->dataLength, &data_local);
    data->data = (uint8_t *) erpc_malloc(data->dataLength * sizeof(uint8_t));
    if ((data->data == NULL) && (data->dataLength > 0))
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->data, data_local, data->dataLength);
    }
}

// Read struct SensorReadResult function implementation
static void read_SensorReadResult_struct(erpc::Codec * codec, SensorReadResult * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->read(&data->address);

    codec->read(&data->temp);
}


//! @brief Function to write struct AlarmInfo
static void write_AlarmInfo_struct(erpc::Codec * codec, const AlarmInfo * data);

//! @brief Function to write struct SensorInfo
static void write_SensorInfo_struct(erpc::Codec * codec, const SensorInfo * data);

//! @brief Function to write struct list_SensorInfo_1_t
static void write_list_SensorInfo_1_t_struct(erpc::Codec * codec, const list_SensorInfo_1_t * data);

//! @brief Function to write struct binary_t
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data);


// Write struct AlarmInfo function implementation
static void write_AlarmInfo_struct(erpc::Codec * codec, const AlarmInfo * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->write(data->temp);

    codec->write(data->enabled);
}

// Write struct SensorInfo function implementation
static void write_SensorInfo_struct(erpc::Codec * codec, const SensorInfo * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->write(data->address);

    codec->write(data->readInterval);

    write_AlarmInfo_struct(codec, &(data->highAlarm));

    write_AlarmInfo_struct(codec, &(data->lowAlarm));
}

// Write struct list_SensorInfo_1_t function implementation
static void write_list_SensorInfo_1_t_struct(erpc::Codec * codec, const list_SensorInfo_1_t * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->startWriteList(data->elementsCount);
    for (uint32_t listCount = 0U; listCount < data->elementsCount; ++listCount)
    {
        write_SensorInfo_struct(codec, &(data->elements[listCount]));
    }
}

// Write struct binary_t function implementation
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->writeBinary(data->dataLength, data->data);
}


//! @brief Function to free space allocated inside struct list_SensorInfo_1_t
static void free_list_SensorInfo_1_t_struct(list_SensorInfo_1_t * data);

//! @brief Function to free space allocated inside struct binary_t
static void free_binary_t_struct(binary_t * data);


// Free space allocated inside struct list_SensorInfo_1_t function implementation
static void free_list_SensorInfo_1_t_struct(list_SensorInfo_1_t * data)
{
    erpc_free(data->elements);
}

// Free space allocated inside struct binary_t function implementation
static void free_binary_t_struct(binary_t * data)
{
    erpc_free(data->data);
}



// Call the correct server shim based on method unique ID.
erpc_status_t Temp_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    erpc_status_t erpcStatus;
    switch (methodId)
    {
        case kTemp_add_sensor_id:
        {
            erpcStatus = add_sensor_shim(codec, messageFactory, sequence);
            break;
        }

        case kTemp_remove_sensor_id:
        {
            erpcStatus = remove_sensor_shim(codec, messageFactory, sequence);
            break;
        }

        case kTemp_set_interval_id:
        {
            erpcStatus = set_interval_shim(codec, messageFactory, sequence);
            break;
        }

        case kTemp_set_alarm_id:
        {
            erpcStatus = set_alarm_shim(codec, messageFactory, sequence);
            break;
        }

        case kTemp_enable_alarm_id:
        {
            erpcStatus = enable_alarm_shim(codec, messageFactory, sequence);
            break;
        }

        case kTemp_disable_alarm_id:
        {
            erpcStatus = disable_alarm_shim(codec, messageFactory, sequence);
            break;
        }

        case kTemp_get_one_sensor_id:
        {
            erpcStatus = get_one_sensor_shim(codec, messageFactory, sequence);
            break;
        }

        case kTemp_get_all_sensors_b_id:
        {
            erpcStatus = get_all_sensors_b_shim(codec, messageFactory, sequence);
            break;
        }

        case kTemp_save_settings_id:
        {
            erpcStatus = save_settings_shim(codec, messageFactory, sequence);
            break;
        }

        case kTemp_load_settings_id:
        {
            erpcStatus = load_settings_shim(codec, messageFactory, sequence);
            break;
        }

        case kTemp_read_one_sensor_id:
        {
            erpcStatus = read_one_sensor_shim(codec, messageFactory, sequence);
            break;
        }

        case kTemp_read_sensors_id:
        {
            erpcStatus = read_sensors_shim(codec, messageFactory, sequence);
            break;
        }

        default:
        {
            erpcStatus = kErpcStatus_InvalidArgument;
            break;
        }
    }

    return erpcStatus;
}

// Server shim for add_sensor of Temp interface.
erpc_status_t Temp_service::add_sensor_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorAddress address;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&address);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = add_sensor(address);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_add_sensor_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for remove_sensor of Temp interface.
erpc_status_t Temp_service::remove_sensor_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorAddress address;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&address);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = remove_sensor(address);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_remove_sensor_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for set_interval of Temp interface.
erpc_status_t Temp_service::set_interval_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorAddress address;
    float interval;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&address);

    codec->read(&interval);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = set_interval(address, interval);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_set_interval_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for set_alarm of Temp interface.
erpc_status_t Temp_service::set_alarm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorAddress address;
    AlarmType alarmType;
    float alarmTemp;
    int32_t _tmp_local;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&address);

    codec->read(&_tmp_local);
    alarmType = static_cast<AlarmType>(_tmp_local);

    codec->read(&alarmTemp);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = set_alarm(address, alarmType, alarmTemp);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_set_alarm_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for enable_alarm of Temp interface.
erpc_status_t Temp_service::enable_alarm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorAddress address;
    AlarmType alarmType;
    int32_t _tmp_local;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&address);

    codec->read(&_tmp_local);
    alarmType = static_cast<AlarmType>(_tmp_local);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = enable_alarm(address, alarmType);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_enable_alarm_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for disable_alarm of Temp interface.
erpc_status_t Temp_service::disable_alarm_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorAddress address;
    AlarmType alarmType;
    int32_t _tmp_local;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&address);

    codec->read(&_tmp_local);
    alarmType = static_cast<AlarmType>(_tmp_local);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = disable_alarm(address, alarmType);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_disable_alarm_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for get_one_sensor of Temp interface.
erpc_status_t Temp_service::get_one_sensor_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorAddress address;
    SensorInfo * result = NULL;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&address);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = get_one_sensor(address);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_get_one_sensor_id, sequence);

        write_SensorInfo_struct(codec, result);

        err = codec->getStatus();
    }

    erpc_free(result);

    return err;
}

// Server shim for get_all_sensors_b of Temp interface.
erpc_status_t Temp_service::get_all_sensors_b_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorInfoList * result = NULL;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = get_all_sensors_b();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_get_all_sensors_b_id, sequence);

        write_list_SensorInfo_1_t_struct(codec, result);

        err = codec->getStatus();
    }

    if (result)
    {
        free_list_SensorInfo_1_t_struct(result);
    }
    erpc_free(result);

    return err;
}

// Server shim for save_settings of Temp interface.
erpc_status_t Temp_service::save_settings_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SavedState * result = NULL;

    // startReadMessage() was already called before this shim was invoked.

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = save_settings();
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_save_settings_id, sequence);

        write_binary_t_struct(codec, result);

        err = codec->getStatus();
    }

    if (result)
    {
        free_binary_t_struct(result);
    }
    erpc_free(result);

    return err;
}

// Server shim for load_settings of Temp interface.
erpc_status_t Temp_service::load_settings_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SavedState *savedState = NULL;
    savedState = (SavedState *) erpc_malloc(sizeof(SavedState));
    if (savedState == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    read_binary_t_struct(codec, savedState);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = load_settings(savedState);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_load_settings_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    if (savedState)
    {
        free_binary_t_struct(savedState);
    }
    erpc_free(savedState);

    return err;
}

// Server shim for read_one_sensor of Temp interface.
erpc_status_t Temp_service::read_one_sensor_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorAddress address;
    float result;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&address);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = read_one_sensor(address);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_read_one_sensor_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for read_sensors of Temp interface.
erpc_status_t Temp_service::read_sensors_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorAddress * addresses = NULL;
    uint32_t count;
    bool result;

    // startReadMessage() was already called before this shim was invoked.

    uint32_t lengthTemp_0;
    codec->startReadList(&lengthTemp_0);
    count = lengthTemp_0;
    addresses = (SensorAddress *) erpc_malloc(lengthTemp_0 * sizeof(SensorAddress));
    if ((addresses == NULL) && (lengthTemp_0 > 0))
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    for (uint32_t listCount0 = 0U; listCount0 < lengthTemp_0; ++listCount0)
    {
        codec->read(&addresses[listCount0]);
    }

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = read_sensors(addresses, count);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTemp_service_id, kTemp_read_sensors_id, sequence);

        codec->write(result);

        err = codec->getStatus();
    }

    erpc_free(addresses);

    return err;
}

// Call the correct server shim based on method unique ID.
erpc_status_t TempAsync_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    erpc_status_t erpcStatus;
    switch (methodId)
    {
        case kTempAsync_alarm_fired_id:
        {
            erpcStatus = alarm_fired_shim(codec, messageFactory, sequence);
            break;
        }

        case kTempAsync_read_results_id:
        {
            erpcStatus = read_results_shim(codec, messageFactory, sequence);
            break;
        }

        default:
        {
            erpcStatus = kErpcStatus_InvalidArgument;
            break;
        }
    }

    return erpcStatus;
}

// Server shim for alarm_fired of TempAsync interface.
erpc_status_t TempAsync_service::alarm_fired_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorAddress addr;
    float temp;

    // startReadMessage() was already called before this shim was invoked.

    codec->read(&addr);

    codec->read(&temp);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        alarm_fired(addr, temp);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kTempAsync_service_id, kTempAsync_alarm_fired_id, sequence);

        err = codec->getStatus();
    }

    return err;
}

// Server shim for read_results of TempAsync interface.
erpc_status_t TempAsync_service::read_results_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorReadResult * results = NULL;
    uint32_t count;

    // startReadMessage() was already called before this shim was invoked.

    uint32_t lengthTemp_0;
    codec->startReadList(&lengthTemp_0);
    count = lengthTemp_0;
    results = (SensorReadResult *) erpc_malloc(lengthTemp_0 * sizeof(SensorReadResult));
    if ((results == NULL) && (lengthTemp_0 > 0))
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    for (uint32_t listCount0 = 0U; listCount0 < lengthTemp_0; ++listCount0)
    {
        read_SensorReadResult_struct(codec, &(results[listCount0]));
    }

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        read_results(results, count);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif
    }

    erpc_free(results);

    return err;
}

#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
erpc_service_t create_Temp_service()
{
    return new (nothrow) Temp_service();
}

void destroy_Temp_service(erpc_service_t service)
{
    if (service)
    {
        delete (Temp_service *)service;
    }
}
#elif ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_STATIC
erpc_service_t create_Temp_service()
{
    s_Temp_service.construct();
    return s_Temp_service.get();
}

void destroy_Temp_service()
{
    s_Temp_service.destroy();
}
#else
#warning "Unknown eRPC allocation policy!"
#endif

#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
erpc_service_t create_TempAsync_service()
{
    return new (nothrow) TempAsync_service();
}

void destroy_TempAsync_service(erpc_service_t service)
{
    if (service)
    {
        delete (TempAsync_service *)service;
    }
}
#elif ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_STATIC
erpc_service_t create_TempAsync_service()
{
    s_TempAsync_service.construct();
    return s_TempAsync_service.get();
}

void destroy_TempAsync_service()
{
    s_TempAsync_service.destroy();
}
#else
#warning "Unknown eRPC allocation policy!"
#endif
