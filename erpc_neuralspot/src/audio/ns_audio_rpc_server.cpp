// @file ns-audio-rpc.erpc
//!
//! @brief Interface definition for neuralspot audio RPC
//!
//!

/*
 * Generated by erpcgen 1.9.1 on Thu Aug 25 16:32:36 2022.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "ns_audio_rpc_server.h"
#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
#include <new>
#include "erpc_port.h"
#endif
#include "erpc_manually_constructed.hpp"

#if 10901 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

#if ERPC_NESTED_CALLS_DETECTION
extern bool nestingDetection;
#endif

ERPC_MANUALLY_CONSTRUCTED_STATIC(ns_audio_rpc_service, s_ns_audio_rpc_service);



// Constant variable definitions
#pragma weak max_audio_buffer_length
extern const int32_t max_audio_buffer_length = 1024;

//! @brief Function to read struct nsAudioBuffer_t
static void read_nsAudioBuffer_t_struct(erpc::Codec * codec, nsAudioBuffer_t * data);

//! @brief Function to read struct audioCommand_t
static void read_audioCommand_t_struct(erpc::Codec * codec, audioCommand_t * data);


// Read struct nsAudioBuffer_t function implementation
static void read_nsAudioBuffer_t_struct(erpc::Codec * codec, nsAudioBuffer_t * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->read(&data->bufferLength);

    uint32_t lengthTemp_0;
    uint8_t * dataTemp_0;
    codec->readBinary(&lengthTemp_0, &dataTemp_0);
    data->buf = (uint8_t *) erpc_malloc(lengthTemp_0 * sizeof(uint8_t));
    if ((data->buf == NULL) && (lengthTemp_0 > 0))
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->buf, dataTemp_0, lengthTemp_0);
    }
}

// Read struct audioCommand_t function implementation
static void read_audioCommand_t_struct(erpc::Codec * codec, audioCommand_t * data)
{
    int32_t _tmp_local;

    if(NULL == data)
    {
        return;
    }

    codec->read(&_tmp_local);
    data->cmd = static_cast<nsAudioAction_e>(_tmp_local);

    read_nsAudioBuffer_t_struct(codec, &(data->buf));
}


//! @brief Function to free space allocated inside struct nsAudioBuffer_t
static void free_nsAudioBuffer_t_struct(nsAudioBuffer_t * data);

//! @brief Function to free space allocated inside struct audioCommand_t
static void free_audioCommand_t_struct(audioCommand_t * data);


// Free space allocated inside struct nsAudioBuffer_t function implementation
static void free_nsAudioBuffer_t_struct(nsAudioBuffer_t * data)
{
    erpc_free(data->buf);
}

// Free space allocated inside struct audioCommand_t function implementation
static void free_audioCommand_t_struct(audioCommand_t * data)
{
    free_nsAudioBuffer_t_struct(&data->buf);
}



// Call the correct server shim based on method unique ID.
erpc_status_t ns_audio_rpc_service::handleInvocation(uint32_t methodId, uint32_t sequence, Codec * codec, MessageBufferFactory *messageFactory)
{
    erpc_status_t erpcStatus;
    switch (methodId)
    {
        case kns_audio_rpc_erpcDumpAudioBuffer_id:
        {
            erpcStatus = erpcDumpAudioBuffer_shim(codec, messageFactory, sequence);
            break;
        }

        default:
        {
            erpcStatus = kErpcStatus_InvalidArgument;
            break;
        }
    }

    return erpcStatus;
}

// Server shim for erpcDumpAudioBuffer of ns_audio_rpc interface.
erpc_status_t ns_audio_rpc_service::erpcDumpAudioBuffer_shim(Codec * codec, MessageBufferFactory *messageFactory, uint32_t sequence)
{
    erpc_status_t err = kErpcStatus_Success;

    audioCommand_t *buf = NULL;
    buf = (audioCommand_t *) erpc_malloc(sizeof(audioCommand_t));
    if (buf == NULL)
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    nsAudioStatus_e result;

    // startReadMessage() was already called before this shim was invoked.

    read_audioCommand_t_struct(codec, buf);

    err = codec->getStatus();
    if (err == kErpcStatus_Success)
    {
        // Invoke the actual served function.
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = true;
#endif
        result = erpcDumpAudioBuffer(buf);
#if ERPC_NESTED_CALLS_DETECTION
        nestingDetection = false;
#endif

        // preparing MessageBuffer for serializing data
        err = messageFactory->prepareServerBufferForSend(codec->getBuffer());
    }

    if (err == kErpcStatus_Success)
    {
        // preparing codec for serializing data
        codec->reset();

        // Build response message.
        codec->startWriteMessage(kReplyMessage, kns_audio_rpc_service_id, kns_audio_rpc_erpcDumpAudioBuffer_id, sequence);

        codec->write(static_cast<int32_t>(result));

        err = codec->getStatus();
    }

    if (buf)
    {
        free_audioCommand_t_struct(buf);
    }
    erpc_free(buf);

    return err;
}

#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
erpc_service_t create_ns_audio_rpc_service()
{
    return new (nothrow) ns_audio_rpc_service();
}

void destroy_ns_audio_rpc_service(erpc_service_t service)
{
    if (service)
    {
        delete (ns_audio_rpc_service *)service;
    }
}
#elif ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_STATIC
erpc_service_t create_ns_audio_rpc_service()
{
    s_ns_audio_rpc_service.construct();
    return s_ns_audio_rpc_service.get();
}

void destroy_ns_audio_rpc_service()
{
    s_ns_audio_rpc_service.destroy();
}
#else
#warning "Unknown eRPC allocation policy!"
#endif
