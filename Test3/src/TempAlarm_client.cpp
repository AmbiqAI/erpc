/*
 * Copyright (c) 2016, Freescale Semiconductor, Inc.
 * Copyright 2016-2017 NXP
 * All rights reserved.
 *
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/*
 * Generated by erpcgen 1.9.1 on Thu Aug 18 10:53:47 2022.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "erpc_client_manager.h"
//#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
#include "erpc_port.h"
//#endif
#include "erpc_codec.hpp"
extern "C"
{
#include "TempAlarm.h"
}

#if 10901 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

extern ClientManager *g_client;

//! @brief Function to write struct binary_t
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data);

//! @brief Function to write struct SensorReadResult
static void write_SensorReadResult_struct(erpc::Codec * codec, const SensorReadResult * data);


// Write struct binary_t function implementation
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->writeBinary(data->dataLength, data->data);
}

// Write struct SensorReadResult function implementation
static void write_SensorReadResult_struct(erpc::Codec * codec, const SensorReadResult * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->write(data->address);

    codec->write(data->temp);
}


//! @brief Function to read struct AlarmInfo
static void read_AlarmInfo_struct(erpc::Codec * codec, AlarmInfo * data);

//! @brief Function to read struct SensorInfo
static void read_SensorInfo_struct(erpc::Codec * codec, SensorInfo * data);

//! @brief Function to read struct list_SensorInfo_1_t
static void read_list_SensorInfo_1_t_struct(erpc::Codec * codec, list_SensorInfo_1_t * data);

//! @brief Function to read struct binary_t
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data);


// Read struct AlarmInfo function implementation
static void read_AlarmInfo_struct(erpc::Codec * codec, AlarmInfo * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->read(&data->temp);

    codec->read(&data->enabled);
}

// Read struct SensorInfo function implementation
static void read_SensorInfo_struct(erpc::Codec * codec, SensorInfo * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->read(&data->address);

    codec->read(&data->readInterval);

    read_AlarmInfo_struct(codec, &(data->highAlarm));

    read_AlarmInfo_struct(codec, &(data->lowAlarm));
}

// Read struct list_SensorInfo_1_t function implementation
static void read_list_SensorInfo_1_t_struct(erpc::Codec * codec, list_SensorInfo_1_t * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->startReadList(&data->elementsCount);
    data->elements = (SensorInfo *) erpc_malloc(data->elementsCount * sizeof(SensorInfo));
    if ((data->elements == NULL) && (data->elementsCount > 0))
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    for (uint32_t listCount = 0U; listCount < data->elementsCount; ++listCount)
    {
        read_SensorInfo_struct(codec, &(data->elements[listCount]));
    }
}

// Read struct binary_t function implementation
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data)
{
    if(NULL == data)
    {
        return;
    }

    uint8_t * data_local;
    codec->readBinary(&data->dataLength, &data_local);
    data->data = (uint8_t *) erpc_malloc(data->dataLength * sizeof(uint8_t));
    if ((data->data == NULL) && (data->dataLength > 0))
    {
        codec->updateStatus(kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->data, data_local, data->dataLength);
    }
}



// Temp interface add_sensor function client shim.
bool add_sensor(SensorAddress address)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_add_sensor_id, request.getSequence());

        codec->write(address);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_add_sensor_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = false;
    }

    return result;
}

// Temp interface remove_sensor function client shim.
bool remove_sensor(SensorAddress address)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_remove_sensor_id, request.getSequence());

        codec->write(address);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_remove_sensor_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = false;
    }

    return result;
}

// Temp interface set_interval function client shim.
bool set_interval(SensorAddress address, float interval)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_set_interval_id, request.getSequence());

        codec->write(address);

        codec->write(interval);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_set_interval_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = false;
    }

    return result;
}

// Temp interface set_alarm function client shim.
bool set_alarm(SensorAddress address, AlarmType alarmType, float alarmTemp)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_set_alarm_id, request.getSequence());

        codec->write(address);

        codec->write(static_cast<int32_t>(alarmType));

        codec->write(alarmTemp);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_set_alarm_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = false;
    }

    return result;
}

// Temp interface enable_alarm function client shim.
bool enable_alarm(SensorAddress address, AlarmType alarmType)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_enable_alarm_id, request.getSequence());

        codec->write(address);

        codec->write(static_cast<int32_t>(alarmType));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_enable_alarm_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = false;
    }

    return result;
}

// Temp interface disable_alarm function client shim.
bool disable_alarm(SensorAddress address, AlarmType alarmType)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_disable_alarm_id, request.getSequence());

        codec->write(address);

        codec->write(static_cast<int32_t>(alarmType));

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_disable_alarm_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = false;
    }

    return result;
}

// Temp interface get_one_sensor function client shim.
SensorInfo * get_one_sensor(SensorAddress address)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorInfo * result = NULL;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_get_one_sensor_id, request.getSequence());

        codec->write(address);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        result = (SensorInfo *) erpc_malloc(sizeof(SensorInfo));
        if (result == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        read_SensorInfo_struct(codec, result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_get_one_sensor_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return result;
}

// Temp interface get_all_sensors_b function client shim.
SensorInfoList * get_all_sensors_b(void)
{
    erpc_status_t err = kErpcStatus_Success;

    SensorInfoList * result = NULL;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_get_all_sensors_b_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        result = (SensorInfoList *) erpc_malloc(sizeof(SensorInfoList));
        if (result == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        read_list_SensorInfo_1_t_struct(codec, result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_get_all_sensors_b_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return result;
}

// Temp interface save_settings function client shim.
SavedState * save_settings(void)
{
    erpc_status_t err = kErpcStatus_Success;

    SavedState * result = NULL;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_save_settings_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        result = (SavedState *) erpc_malloc(sizeof(SavedState));
        if (result == NULL)
        {
            codec->updateStatus(kErpcStatus_MemoryError);
        }
        read_binary_t_struct(codec, result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_save_settings_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return result;
}

// Temp interface load_settings function client shim.
bool load_settings(const SavedState * savedState)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_load_settings_id, request.getSequence());

        write_binary_t_struct(codec, savedState);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_load_settings_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = false;
    }

    return result;
}

// Temp interface read_one_sensor function client shim.
float read_one_sensor(SensorAddress address)
{
    erpc_status_t err = kErpcStatus_Success;

    float result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_read_one_sensor_id, request.getSequence());

        codec->write(address);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_read_one_sensor_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = -1;
    }

    return result;
}

// Temp interface read_sensors function client shim.
bool read_sensors(const SensorAddress * addresses, uint32_t count)
{
    erpc_status_t err = kErpcStatus_Success;

    bool result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTemp_service_id, kTemp_read_sensors_id, request.getSequence());

        codec->startWriteList(count);
        for (uint32_t listCount0 = 0U; listCount0 < count; ++listCount0)
        {
            codec->write(addresses[listCount0]);
        }

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTemp_read_sensors_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = false;
    }

    return result;
}

// TempAsync interface alarm_fired function client shim.
void alarm_fired(SensorAddress addr, float temp)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kTempAsync_service_id, kTempAsync_alarm_fired_id, request.getSequence());

        codec->write(addr);

        codec->write(temp);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTempAsync_alarm_fired_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}

// TempAsync interface read_results function client shim.
void read_results(const SensorReadResult * results, uint32_t count)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kTempAsync_service_id, kTempAsync_read_results_id, request.getSequence());

        codec->startWriteList(count);
        for (uint32_t listCount0 = 0U; listCount0 < count; ++listCount0)
        {
            write_SensorReadResult_struct(codec, &(results[listCount0]));
        }

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kTempAsync_read_results_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}
