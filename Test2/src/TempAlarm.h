/*
 * Copyright (c) 2016, Freescale Semiconductor, Inc.
 * Copyright 2016-2017 NXP
 * All rights reserved.
 *
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/*
 * Generated by erpcgen 1.9.1 on Thu Aug 18 10:53:47 2022.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#if !defined(_TempAlarm_h_)
#define _TempAlarm_h_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include "erpc_version.h"

#if 10901 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

#if !defined(ERPC_TYPE_DEFINITIONS)
#define ERPC_TYPE_DEFINITIONS

// Enumerators data types declarations
typedef enum AlarmType
{
    kHighAlarm = 0,
    kLowAlarm = 1,
    kBothAlarms = 2 //!< Only used for enable/disable.
} AlarmType;

// Aliases data types declarations
typedef struct binary_t binary_t;
typedef struct SensorReadResult SensorReadResult;
typedef struct AlarmInfo AlarmInfo;
typedef struct SensorInfo SensorInfo;
typedef struct list_SensorInfo_1_t list_SensorInfo_1_t;
typedef uint8_t SensorAddress;
typedef list_SensorInfo_1_t SensorInfoList;
typedef binary_t SavedState;

// Structures/unions data types declarations
struct binary_t
{
    uint8_t * data;
    uint32_t dataLength;
};

struct SensorReadResult
{
    SensorAddress address;
    float temp;
};

struct AlarmInfo
{
    float temp;
    bool enabled;
};

struct SensorInfo
{
    SensorAddress address;
    float readInterval; //!< Seconds, default 1s.
    AlarmInfo highAlarm;
    AlarmInfo lowAlarm;
};

struct list_SensorInfo_1_t
{
    SensorInfo * elements;
    uint32_t elementsCount;
};


#endif // ERPC_TYPE_DEFINITIONS

/*! @brief Temp identifiers */
enum _Temp_ids
{
    kTemp_service_id = 1,
    kTemp_add_sensor_id = 1,
    kTemp_remove_sensor_id = 2,
    kTemp_set_interval_id = 3,
    kTemp_set_alarm_id = 4,
    kTemp_enable_alarm_id = 5,
    kTemp_disable_alarm_id = 6,
    kTemp_get_one_sensor_id = 7,
    kTemp_get_all_sensors_b_id = 8,
    kTemp_save_settings_id = 9,
    kTemp_load_settings_id = 10,
    kTemp_read_one_sensor_id = 11,
    kTemp_read_sensors_id = 12,
};

/*! @brief TempAsync identifiers */
enum _TempAsync_ids
{
    kTempAsync_service_id = 2,
    kTempAsync_alarm_fired_id = 1,
    kTempAsync_read_results_id = 2,
};

#if defined(__cplusplus)
extern "C" {
#endif

//! Calls from Linux to M4.
//! @name Temp
//@{
bool add_sensor(SensorAddress address);

bool remove_sensor(SensorAddress address);

bool set_interval(SensorAddress address, float interval);

bool set_alarm(SensorAddress address, AlarmType alarmType, float alarmTemp);

bool enable_alarm(SensorAddress address, AlarmType alarmType);

bool disable_alarm(SensorAddress address, AlarmType alarmType);

SensorInfo * get_one_sensor(SensorAddress address);

SensorInfoList * get_all_sensors_b(void);

SavedState * save_settings(void);

bool load_settings(const SavedState * savedState);

//! Reads one sensor synchronously.
float read_one_sensor(SensorAddress address);

//! Sends read_results() asynchronously.
bool read_sensors(const SensorAddress * addresses, uint32_t count);
//@}

//! Asynchronous events from M4 to Linux.
//! @name TempAsync
//@{
//! Void return so we can verify the message was received.
void alarm_fired(SensorAddress addr, float temp);

//! Oneway since it's less important than an alarm.
void read_results(const SensorReadResult * results, uint32_t count);
//@}

#if defined(__cplusplus)
}
#endif

#endif // _TempAlarm_h_
